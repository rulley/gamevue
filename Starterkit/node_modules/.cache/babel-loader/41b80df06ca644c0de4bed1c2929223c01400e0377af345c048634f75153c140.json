{"ast":null,"code":"import _regeneratorRuntime from \"/Users/michaelrellaford/Documents/gamevue/Starterkit/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/michaelrellaford/Documents/gamevue/Starterkit/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/michaelrellaford/Documents/gamevue/Starterkit/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n// import Vue from 'vue'\nimport { createRouter, createWebHistory } from 'vue-router';\n// https://github.com/declandewet/vue-meta\n// import VueMeta from 'vue-meta'\n\nimport store from '@/state/store';\nimport routes from './routes';\n\n// Vue.use(VueRouter)\n// Vue.use(VueMeta, {\n//   // The component option name that vue-meta looks for meta info on.\n//   keyName: 'page',\n// })\n\nvar router = createRouter({\n  // 4. Provide the history implementation to use. We are using the hash history for simplicity here.\n  history: createWebHistory(),\n  routes: routes,\n  // short for `routes: routes`,\n  scrollBehavior: function scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition;\n    } else {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n  }\n});\n\n// const router = new VueRouter({\n//   routes,\n//   // Use the HTML5 history API (i.e. normal-looking routes)\n//   // instead of routes with hashes (e.g. example.com/#/about).\n//   // This may require some server configuration in production:\n//   // https://router.vuejs.org/en/essentials/history-mode.html#example-server-configurations\n//   mode: 'history',\n//   // Simulate native-like scroll behavior when navigating to a new\n//   // route and using back/forward buttons.\n//   scrollBehavior(to, from, savedPosition) {\n//     if (savedPosition) {\n//       return savedPosition\n//     } else {\n//       return {\n//         x: 0,\n//         y: 0\n//       }\n//     }\n//   },\n// })\n\n// Before each route evaluates...\nrouter.beforeEach(function (routeTo, routeFrom, next) {\n  if (process.env.VUE_APP_DEFAULT_AUTH === \"firebase\") {\n    // eslint-disable-next-line no-unused-vars\n    // eslint-disable-next-line no-inner-declarations\n    var redirectToLogin = function redirectToLogin() {\n      // Pass the original route to the login component\n      next({\n        name: 'login',\n        query: {\n          redirectFrom: routeTo.fullPath\n        }\n      });\n    };\n    // Check if auth is required on this route\n    // (including nested routes).\n    var authRequired = routeTo.matched.some(function (route) {\n      return route.meta.authRequired;\n    });\n\n    // If auth isn't required for the route, just continue.\n    if (!authRequired) return next();\n\n    // If auth is required and the user is logged in...\n    if (store.getters['auth/loggedIn']) {\n      // Validate the local user token...\n      return store.dispatch('auth/validate').then(function (validUser) {\n        // Then continue if the token still represents a valid user,\n        // otherwise redirect to login.\n        validUser ? next() : redirectToLogin();\n      });\n    }\n\n    // If auth is required and the user is NOT currently logged in,\n    // redirect to login.\n    redirectToLogin();\n  } else {\n    var publicPages = ['/login', '/register', '/forgot-password'];\n    var authpage = !publicPages.includes(routeTo.path);\n    var loggeduser = localStorage.getItem('user');\n    if (authpage && !loggeduser) {\n      return next('/login');\n    }\n    next();\n  }\n});\nrouter.beforeResolve( /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(routeTo, routeFrom, next) {\n    var _iterator, _step, _loop;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.prev = 0;\n          // For each matched route...\n          _iterator = _createForOfIteratorHelper(routeTo.matched);\n          _context2.prev = 2;\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n            var route;\n            return _regeneratorRuntime().wrap(function _loop$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  route = _step.value;\n                  _context.next = 3;\n                  return new Promise(function (resolve, reject) {\n                    // If a `beforeResolve` hook is defined, call it with\n                    // the same arguments as the `beforeEnter` hook.\n                    if (route.meta && route.meta.beforeResolve) {\n                      route.meta.beforeResolve(routeTo, routeFrom, function () {\n                        // If the user chose to redirect...\n                        if (arguments.length) {\n                          // If redirecting to the same route we're coming from...\n                          // Complete the redirect.\n                          next.apply(void 0, arguments);\n                          reject(new Error('Redirected'));\n                        } else {\n                          resolve();\n                        }\n                      });\n                    } else {\n                      // Otherwise, continue resolving the route.\n                      resolve();\n                    }\n                  });\n                case 3:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _loop);\n          });\n          _iterator.s();\n        case 5:\n          if ((_step = _iterator.n()).done) {\n            _context2.next = 9;\n            break;\n          }\n          return _context2.delegateYield(_loop(), \"t0\", 7);\n        case 7:\n          _context2.next = 5;\n          break;\n        case 9:\n          _context2.next = 14;\n          break;\n        case 11:\n          _context2.prev = 11;\n          _context2.t1 = _context2[\"catch\"](2);\n          _iterator.e(_context2.t1);\n        case 14:\n          _context2.prev = 14;\n          _iterator.f();\n          return _context2.finish(14);\n        case 17:\n          _context2.next = 22;\n          break;\n        case 19:\n          _context2.prev = 19;\n          _context2.t2 = _context2[\"catch\"](0);\n          return _context2.abrupt(\"return\");\n        case 22:\n          // If we reach this point, continue resolving the route.\n          next();\n        case 23:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee, null, [[0, 19], [2, 11, 14, 17]]);\n  }));\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}());\nexport default router;","map":{"version":3,"names":["createRouter","createWebHistory","store","routes","router","history","scrollBehavior","to","from","savedPosition","x","y","beforeEach","routeTo","routeFrom","next","process","env","VUE_APP_DEFAULT_AUTH","redirectToLogin","name","query","redirectFrom","fullPath","authRequired","matched","some","route","meta","getters","dispatch","then","validUser","publicPages","authpage","includes","path","loggeduser","localStorage","getItem","beforeResolve","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_iterator","_step","_loop","wrap","_callee$","_context2","prev","_createForOfIteratorHelper","_loop$","_context","value","Promise","resolve","reject","arguments","length","apply","Error","stop","s","n","done","delegateYield","t1","e","f","finish","t2","abrupt","_x","_x2","_x3"],"sources":["/Users/michaelrellaford/Documents/gamevue/Starterkit/src/router/index.js"],"sourcesContent":["// import Vue from 'vue'\nimport { createRouter, createWebHistory } from 'vue-router'\n// https://github.com/declandewet/vue-meta\n// import VueMeta from 'vue-meta'\n\nimport store from '@/state/store'\nimport routes from './routes'\n\n// Vue.use(VueRouter)\n// Vue.use(VueMeta, {\n//   // The component option name that vue-meta looks for meta info on.\n//   keyName: 'page',\n// })\n\nconst router = createRouter({\n  // 4. Provide the history implementation to use. We are using the hash history for simplicity here.\n  history: createWebHistory(),\n  routes, // short for `routes: routes`,\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition\n    } else {\n      return {\n        x: 0,\n        y: 0\n      }\n    }\n  }\n})\n\n// const router = new VueRouter({\n//   routes,\n//   // Use the HTML5 history API (i.e. normal-looking routes)\n//   // instead of routes with hashes (e.g. example.com/#/about).\n//   // This may require some server configuration in production:\n//   // https://router.vuejs.org/en/essentials/history-mode.html#example-server-configurations\n//   mode: 'history',\n//   // Simulate native-like scroll behavior when navigating to a new\n//   // route and using back/forward buttons.\n//   scrollBehavior(to, from, savedPosition) {\n//     if (savedPosition) {\n//       return savedPosition\n//     } else {\n//       return {\n//         x: 0,\n//         y: 0\n//       }\n//     }\n//   },\n// })\n\n// Before each route evaluates...\nrouter.beforeEach((routeTo, routeFrom, next) => {\n  if (process.env.VUE_APP_DEFAULT_AUTH === \"firebase\") {\n    // Check if auth is required on this route\n    // (including nested routes).\n    const authRequired = routeTo.matched.some((route) => route.meta.authRequired)\n\n    // If auth isn't required for the route, just continue.\n    if (!authRequired) return next()\n\n    // If auth is required and the user is logged in...\n    if (store.getters['auth/loggedIn']) {\n      // Validate the local user token...\n      return store.dispatch('auth/validate').then((validUser) => {\n        // Then continue if the token still represents a valid user,\n        // otherwise redirect to login.\n        validUser ? next() : redirectToLogin()\n      })\n    }\n\n    // If auth is required and the user is NOT currently logged in,\n    // redirect to login.\n    redirectToLogin()\n\n    // eslint-disable-next-line no-unused-vars\n    // eslint-disable-next-line no-inner-declarations\n    function redirectToLogin() {\n      // Pass the original route to the login component\n      next({\n        name: 'login',\n        query: {\n          redirectFrom: routeTo.fullPath\n        }\n      })\n    }\n  } else {\n    const publicPages = ['/login', '/register', '/forgot-password'];\n    const authpage = !publicPages.includes(routeTo.path);\n    const loggeduser = localStorage.getItem('user');\n\n    if (authpage && !loggeduser) {\n      return next('/login');\n    }\n\n    next();\n  }\n})\n\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\n  // Create a `beforeResolve` hook, which fires whenever\n  // `beforeRouteEnter` and `beforeRouteUpdate` would. This\n  // allows us to ensure data is fetched even when params change,\n  // but the resolved route does not. We put it in `meta` to\n  // indicate that it's a hook we created, rather than part of\n  // Vue Router (yet?).\n  try {\n    // For each matched route...\n    for (const route of routeTo.matched) {\n      await new Promise((resolve, reject) => {\n        // If a `beforeResolve` hook is defined, call it with\n        // the same arguments as the `beforeEnter` hook.\n        if (route.meta && route.meta.beforeResolve) {\n          route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\n            // If the user chose to redirect...\n            if (args.length) {\n              // If redirecting to the same route we're coming from...\n              // Complete the redirect.\n              next(...args)\n              reject(new Error('Redirected'))\n            } else {\n              resolve()\n            }\n          })\n        } else {\n          // Otherwise, continue resolving the route.\n          resolve()\n        }\n      })\n    }\n    // If a `beforeResolve` hook chose to redirect, just return.\n  } catch (error) {\n    return\n  }\n\n  // If we reach this point, continue resolving the route.\n  next()\n})\n\nexport default router"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
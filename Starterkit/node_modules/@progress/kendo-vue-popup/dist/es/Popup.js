// @ts-ignore
import * as Vue from 'vue';
var allVue = Vue;
var gh = allVue.h;
var isV3 = allVue.version && allVue.version[0] === '3';
import { Slide } from '@progress/kendo-vue-animation';
import { CollisionType, AlignPoint, throttle, FRAME_DURATION, isWindowAvailable } from './util';
import { AlignService } from './services/alignService';
import { DOMService } from './services/domService';
import { PositionService } from './services/positionService';
import { canUseDOM, getDefaultSlots, validatePackage } from '@progress/kendo-vue-common';
import { packageMetadata } from './package-metadata';
var DEFAULT_POPUP_ZINDEX = 100;
var ZINDEX_POPUP_STEP = 1;
var DEFAULT_OFFSET = {
  left: -1000,
  top: 0
};
var ANIMATION_CONTAINER = 'k-animation-container';
var ANIMATION_CONTAINER_SHOWN = 'k-animation-container-shown';
var K_POPUP = 'k-popup';
/**
 * @hidden
 */
var PopupVue2 = {
  name: 'Popup',
  props: {
    appendTo: {
      type: String,
      default: ''
    },
    anchor: {
      type: String,
      default: ''
    },
    className: String,
    id: String,
    popupClass: String,
    collision: {
      type: Object,
      default: function _default() {
        return {
          horizontal: CollisionType.fit,
          vertical: CollisionType.flip
        };
      }
    },
    anchorAlign: {
      type: Object,
      default: function _default() {
        return {
          horizontal: AlignPoint.left,
          vertical: AlignPoint.bottom
        };
      }
    },
    popupAlign: {
      type: Object,
      default: function _default() {
        return {
          horizontal: AlignPoint.left,
          vertical: AlignPoint.top
        };
      }
    },
    offset: {
      type: Object,
      default: function _default() {
        return DEFAULT_OFFSET;
      }
    },
    show: {
      type: Boolean,
      default: false
    },
    animate: {
      type: [Boolean, Object],
      default: function _default() {
        return true;
      }
    },
    direction: {
      type: String,
      default: 'down'
    },
    transition: {
      type: String,
      default: 'expand'
    }
  },
  inject: {
    kCurrentZIndex: {
      default: null
    }
  },
  data: function data() {
    return {
      hasMounted: false
    };
  },
  created: function created() {
    validatePackage(packageMetadata);
    this.mountedAppendTo = undefined;
    this.mountedAnchor = undefined;
    this._clonedElement = undefined;
    this._flipped = false;
    this._offsetTop = 0;
    this._offsetLeft = -1000;
    this._exitingAnimation = false;
    this._prevShow = false;
    this._prevShow = this.$props.show;
    this._domService = new DOMService();
    this._alignService = new AlignService(this._domService);
    this._positionService = new PositionService(this._domService);
    this.reposition = throttle(this.reposition.bind(this), FRAME_DURATION);
  },
  // @ts-ignore
  setup: !isV3 ? undefined : function () {
    var v3 = !!isV3;
    return {
      v3: v3
    };
  },
  mounted: function mounted() {
    if (canUseDOM) {
      this.mountedAppendTo = this.appendTo ? this.getParentRef(this.appendTo) : document.body;
      this.mountedAnchor = this.anchor ? this.getParentRef(this.anchor, true) : document.body;
    }
    this._parentElement = this.$el.parentElement;
    this._clonedElement = this.$el.cloneNode(true);
    this.hasMounted = true;
    this.mountedAppendTo.appendChild(this.$el);
  },
  updated: function updated() {
    this._prevShow = this.$props.show;
  },
  destroyed: !!isV3 ? undefined : function () {
    this.detachRepositionHandlers();
  },
  beforeDestroy: !!isV3 ? undefined : function () {
    if (this._parentElement) {
      this._parentElement.appendChild(this.$el);
    }
  },
  // @ts-ignore
  unmounted: function unmounted() {
    this.detachRepositionHandlers();
  },
  // @ts-ignore
  beforeUnmount: function beforeUnmount() {
    if (this._parentElement) {
      this._parentElement.appendChild(this.$el);
    }
  },
  methods: {
    onOpened: function onOpened() {
      var element = this.$el;
      if (this.$props.show) {
        element.classList.add(ANIMATION_CONTAINER_SHOWN);
      }
      this.attachRepositionHandlers(element);
      this.$emit('open', {
        target: this
      });
    },
    onClosing: function onClosing() {
      if (!this.$props.show) {
        var element = this.$el;
        element.classList.remove(ANIMATION_CONTAINER_SHOWN);
      }
      this.detachRepositionHandlers();
    },
    onClosed: function onClosed() {
      if (this._exitingAnimation) {
        this._exitingAnimation = false;
        this.$forceUpdate();
      }
      this.$emit('close', {
        target: this
      });
    },
    transitionDuration: function transitionDuration() {
      var animate = this.$props.animate;
      var transitionEnterDuration = 0;
      var transitionExitDuration = 0;
      if (animate) {
        if (animate === true) {
          // Inherit the default duration of the Animation component.
          transitionEnterDuration = transitionExitDuration = undefined;
        } else {
          transitionEnterDuration = animate.openDuration;
          transitionExitDuration = animate.closeDuration;
        }
      }
      return {
        transitionEnterDuration: transitionEnterDuration,
        transitionExitDuration: transitionExitDuration
      };
    },
    getParentRef: function getParentRef(anchor, isAnchor) {
      // @ts-ignore
      var parent = this.$parent;
      while (!parent.$refs[anchor]) {
        // @ts-ignore
        if (parent && parent.kendoAnchorRef && isAnchor) {
          // @ts-ignore
          return parent.kendoAnchorRef;
        }
        // @ts-ignore
        parent = parent.$parent;
        if (!parent && canUseDOM) {
          return document.getElementById(anchor) || document.body;
        }
      }
      // @ts-ignore
      return parent.$refs[anchor].$el || parent.$refs[anchor];
    },
    position: function position(settings, element, anchor) {
      var anchorAlign = settings.anchorAlign,
        popupAlign = settings.popupAlign,
        collision = settings.collision,
        offset = settings.offset;
      var anchorElement = anchor ? this.v3 ? this.mountedAnchor : this.getParentRef(anchor, true) : document.body;
      var alignedOffset = this._alignService.alignElement({
        anchor: anchor ? anchorElement : undefined,
        element: element,
        elementAlign: popupAlign,
        anchorAlign: anchorAlign,
        offset: offset
      });
      var result = this._positionService.positionElement({
        anchor: anchorElement,
        anchorAlign: anchorAlign,
        collisions: collision,
        element: element,
        currentLocation: alignedOffset,
        elementAlign: popupAlign
      });
      return result;
    },
    calculatePosition: function calculatePosition($props, appendToElement) {
      if (!appendToElement || !isWindowAvailable() || !canUseDOM) {
        return {
          flipped: false,
          offset: $props.offset
        };
      }
      var defaultSlot = getDefaultSlots(this);
      var root = document.createElement('div');
      var contentElement = this.$el && this.$el.firstChild ? this.$el.firstChild.firstChild ? this.$el.firstChild.firstChild.cloneNode(true) : null : null;
      var divWrapper = contentElement && contentElement.getBoundingClientRect ? contentElement : this._clonedElement;
      if (divWrapper) {
        root.appendChild(divWrapper);
      } else {
        // @ts-ignore
        var internalClass = this.v3 ? defaultSlot && defaultSlot[0].props ? defaultSlot[0].props.class : '' : defaultSlot && defaultSlot[0].data ? defaultSlot[0].data.staticClass : '';
        // @ts-ignore
        var domClass = this.v3 ? this.$props.popupClass ? this.$props.popupClass : '' : defaultSlot && defaultSlot[0].data ? defaultSlot[0].data.class : '';
        root.innerHTML = "<div class=\"k-animation-container k-animation-container-relative\">\t\n                        <div class=\"k-popup k-animation-container k-animation-container-relative\">\n                            <div class=\"".concat(internalClass, " ").concat(domClass, "\" >\n                            </div>\t\n                        </div>\t\n                </div>");
      }
      appendToElement.appendChild(root);
      if (root && root.firstChild) {
        var firstChild = root.firstChild;
        firstChild.style.position = 'absolute';
        firstChild.style.visibility = 'hidden';
        firstChild.style.display = 'block';
        firstChild.style.left = '-1000';
        firstChild.style.top = '0';
        var inlineStyles = this.v3 ? defaultSlot && defaultSlot[0].props ? defaultSlot[0].props.style : {} : defaultSlot[0].data ? defaultSlot[0].data.style : {};
        if (inlineStyles) {
          for (var _i = 0, _a = Object.entries(inlineStyles); _i < _a.length; _i++) {
            var _b = _a[_i],
              key = _b[0],
              value = _b[1];
            firstChild.style[key] = value;
          }
        }
      }
      var newPosition = this.position($props, root.firstChild, this.$props.anchor);
      root.parentNode.removeChild(root);
      return newPosition;
    },
    attachRepositionHandlers: function attachRepositionHandlers(element) {
      var _this = this;
      this.detachRepositionHandlers();
      this._scrollableParents = this._domService.scrollableParents(this.$props.anchor ? this.mountedAnchor : element);
      this._scrollableParents.map(function (p) {
        return p.addEventListener('scroll', _this.reposition);
      });
      window.addEventListener('resize', this.reposition);
    },
    detachRepositionHandlers: function detachRepositionHandlers() {
      var _this = this;
      if (this._scrollableParents) {
        this._scrollableParents.map(function (p) {
          return p.removeEventListener('scroll', _this.reposition);
        });
        this._scrollableParents = undefined;
      }
      window.removeEventListener('resize', this.reposition);
    },
    reposition: function reposition() {
      this._clonedElement = this.$el.cloneNode(true);
      this.$forceUpdate();
    },
    getCurrentZIndex: function getCurrentZIndex() {
      return this.kCurrentZIndex ? this.kCurrentZIndex + ZINDEX_POPUP_STEP : DEFAULT_POPUP_ZINDEX;
    }
  },
  // @ts-ignore
  render: function render(createElement) {
    var h = gh || createElement;
    var _a = this.$props,
      className = _a.className,
      popupClass = _a.popupClass,
      show = _a.show,
      id = _a.id;
    var defaultSlots = getDefaultSlots(this);
    var defaultSlot = this.v3 ? defaultSlots : show ? defaultSlots : null;
    var defaultAppentTo = isWindowAvailable() ? this.$props.appendTo ? this.mountedAppendTo || this.getParentRef(this.$props.appendTo) : document.body : undefined;
    if (this.$props.show) {
      var newPosition = this.calculatePosition(this.$props, defaultAppentTo);
      this._offsetLeft = newPosition.offset.left;
      this._offsetTop = newPosition.offset.top;
      this._flipped = !!newPosition.flipped;
    }
    var direction = this.$props.direction === 'down' ? this._flipped ? 'up' : 'down' : this._flipped ? 'down' : 'up';
    var _b = this.transitionDuration(),
      transitionEnterDuration = _b.transitionEnterDuration,
      transitionExitDuration = _b.transitionExitDuration;
    var currentZIndex = this.getCurrentZIndex();
    this._exitingAnimation = this._exitingAnimation || this._prevShow && !show;
    if (!this.hasMounted) {
      return h("div", {
        style: {
          display: 'none'
        },
        "class": className
      }, [h("div", {
        "class": [popupClass, K_POPUP]
      }, [defaultSlots])]);
    }
    if (show || this._exitingAnimation && defaultAppentTo) {
      var popup =
      // @ts-ignore function children
      h(Slide, {
        id: id,
        attrs: this.v3 ? undefined : {
          id: id,
          role: this.appendTo ? '' : 'region',
          componentChildClassName: [popupClass, K_POPUP],
          className: className,
          direction: direction,
          transitionEnterDuration: transitionEnterDuration,
          transitionExitDuration: transitionExitDuration,
          appear: show
        },
        role: this.appendTo ? '' : 'region',
        componentChildClassName: [popupClass, K_POPUP],
        className: className,
        onEntered: this.onOpened,
        on: this.v3 ? undefined : {
          "entered": this.onOpened,
          "exiting": this.onClosing,
          "exited": this.onClosed
        },
        onExiting: this.onClosing,
        onExited: this.onClosed,
        direction: direction,
        style: {
          zIndex: currentZIndex,
          position: 'absolute',
          top: this._offsetTop + 'px',
          left: this._offsetLeft + 'px'
        },
        transitionEnterDuration: transitionEnterDuration,
        transitionExitDuration: transitionExitDuration,
        appear: show
      }, this.v3 ? function () {
        return [defaultSlot];
      } : [defaultSlot]);
      return popup;
    }
    return null;
  }
};
/**
 * @hidden
 */
var Popup = PopupVue2;
export { Popup, PopupVue2 };